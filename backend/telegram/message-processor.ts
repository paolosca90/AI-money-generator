import { sendMessage, createInlineKeyboard } from "./telegram-client";
import { predict } from "../analysis/predict";
import { execute } from "../analysis/execute";
import { getPerformance } from "../analysis/performance";
import { handleVPSCommand, handleVPSSetup, handleVPSSetupCallback } from "./vps-manager";
import { handleClientCommands, checkClientFeature } from "./client-manager";
import { 
  getUserPreferences, 
  setUserPreferences, 
  getUserState, 
  setUserState, 
  clearUserState,
  USER_STATES,
  getTradingModeInfo,
  getAllTradingModesInfo,
  UserPreferences 
} from "./user-state-manager";
import { TradingStrategy } from "../analysis/trading-strategies";

export async function processMessage(chatId: number, userId: number, text: string): Promise<void> {
  const command = text.toLowerCase().trim();

  try {
    // Check if user is in a state that requires specific handling
    const userState = await getUserState(userId);
    if (userState && userState.currentState !== USER_STATES.READY_TO_TRADE) {
      await handleUserStateFlow(chatId, userId, text, userState);
      return;
    }

    if (command.startsWith("/predict")) {
      // Check if user has signal access
      const hasAccess = await checkClientFeature(userId, "basic_signals") ||
                       await checkClientFeature(userId, "advanced_signals") ||
                       await checkClientFeature(userId, "premium_signals");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access AI signals. Use `/subscription` to learn more.");
        return;
      }
      
      await handlePredictCommand(chatId, command, userId);
    } else if (command.startsWith("/scalping")) {
      await handleStrategyCommand(chatId, command, "SCALPING", userId);
    } else if (command.startsWith("/intraday")) {
      await handleStrategyCommand(chatId, command, "INTRADAY", userId);
    } else if (command.startsWith("/swing")) {
      await handleStrategyCommand(chatId, command, "SWING", userId);
    } else if (command.startsWith("/execute")) {
      await handleExecuteCommand(chatId, command);
    } else if (command === "/start") {
      await handleStartCommand(chatId, userId);
    } else if (command === "/help") {
      await handleHelpCommand(chatId);
    } else if (command === "/status") {
      await handleStatusCommand(chatId);
    } else if (command === "/performance") {
      await handlePerformanceCommand(chatId);
    } else if (command.startsWith("/symbols")) {
      await handleSymbolsCommand(chatId);
    } else if (command.startsWith("/strategies")) {
      await handleStrategiesCommand(chatId);
    } else if (command.startsWith("/vps")) {
      // Check if user has VPS management access
      const hasAccess = await checkClientFeature(userId, "vps_management");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access VPS management. Use `/subscription` to learn more.");
        return;
      }
      
      await handleVPSCommand(chatId, userId, command);
    } else if (command === "/vps_setup") {
      // Check if user has VPS management access
      const hasAccess = await checkClientFeature(userId, "vps_management");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access VPS setup. Use `/subscription` to learn more.");
        return;
      }
      
      await handleVPSSetup(chatId, userId);
    } else if (command === "/subscription" || command === "/features" || command === "/upgrade" || command === "/support") {
      await handleClientCommands(chatId, userId, command);
    } else if (command === "/settings") {
      await handleSettingsCommand(chatId, userId);
    } else {
      // Check if user is in VPS setup mode by checking if they have an active state
      const userState = await getUserState(userId);
      if (userState && userState.currentState !== USER_STATES.READY_TO_TRADE) {
        await handleUserStateFlow(chatId, userId, text, userState);
      } else {
        // Default VPS setup handler for unrecognized commands
        await handleVPSSetup(chatId, userId, text);
      }
    }
  } catch (error) {
    console.error("Error processing message:", error);
    await sendMessage(chatId, "‚ùå An error occurred while processing your request. Please try again.");
  }
}

export async function processCallbackQuery(chatId: number, userId: number, callbackData: string): Promise<void> {
  try {
    if (callbackData.startsWith("vps_")) {
      await handleVPSSetupCallback(chatId, userId, callbackData);
    }
    else if (callbackData.startsWith("mode_")) {
      const mode = callbackData.replace("mode_", "") as TradingStrategy;
      await handleTradingModeSelection(chatId, userId, mode);
    }
    else if (callbackData.startsWith("execute_")) {
      const parts = callbackData.split("_");
      const tradeId = parts[1];
      const lotSize = parseFloat(parts[2]);
      const strategy = parts[3] || "INTRADAY";
      await executeTradeFromCallback(chatId, tradeId, lotSize, strategy);
    }
    else if (callbackData.startsWith("strategy_")) {
      const parts = callbackData.split("_");
      const strategy = parts[1] as "SCALPING" | "INTRADAY" | "SWING";
      const symbol = parts[2] || "BTCUSD";
      await handleStrategyCommand(chatId, `/predict ${symbol}`, strategy, userId);
    }
    else if (callbackData === "new_analysis") {
      await sendMessage(chatId, "üìä Choose your trading strategy:\n\n‚ö° `/scalping SYMBOL` - Quick trades (1-15 min)\nüìà `/intraday SYMBOL` - Day trading (1-8 hours)\nüéØ `/swing SYMBOL` - Multi-day trades (1-7 days)\n\nExample: `/scalping EURUSD`");
    }
    else if (callbackData === "show_performance") {
      await handlePerformanceCommand(chatId);
    }
    else if (callbackData.startsWith("predict_")) {
      const symbol = callbackData.replace("predict_", "");
      await handlePredictCommand(chatId, `/predict ${symbol}`, userId);
    }
    else if (callbackData === "show_help") {
      await handleHelpCommand(chatId);
    }
    else if (callbackData === "show_strategies") {
      await handleStrategiesCommand(chatId);
    }
    else if (callbackData === "setup_trading_mode") {
      await startTradingModeSetup(chatId, userId);
    }
    else if (callbackData === "show_settings") {
      await handleSettingsCommand(chatId, userId);
    }
    else if (callbackData === "vps_setup") {
      await handleVPSSetup(chatId, userId);
    }
  }
  catch (error) {
    console.error("Error processing callback query:", error);
    await sendMessage(chatId, "‚ùå Error processing your request. Please try again.");
  }
}

async function executeTradeFromCallback(chatId: number, tradeId: string, lotSize: number, strategy: string): Promise<void> {
  try {
    const result = await execute({ tradeId, lotSize, strategy: strategy as TradingStrategy });
    const message = `
‚úÖ **Trade Executed Successfully!**

üÜî **Trade ID:** \`${tradeId}\`
üìä **Strategy:** ${strategy}
üíé **Lot Size:** ${lotSize}
üí∞ **Execution Price:** ${result.executionPrice || 'N/A'}
üÜî **Order ID:** ${result.orderId || 'N/A'}

‚è∞ **Execution Time:** ${new Date().toLocaleTimeString()}

**Your position is now active on MT5!**
    `;
    await sendMessage(chatId, message);
  }
  catch (error) {
    console.error("Error executing trade:", error);
    await sendMessage(chatId, "‚ùå Error executing trade. Please check your MT5 connection and try again.");
  }
}

async function handleUserStateFlow(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const command = text.toLowerCase().trim();
  switch (userState.currentState) {
    case USER_STATES.SETTING_RISK_AMOUNT:
      await handleRiskAmountInput(chatId, userId, text, userState);
      break;
    case USER_STATES.SETTING_ACCOUNT_BALANCE:
      await handleAccountBalanceInput(chatId, userId, text, userState);
      break;
    default:
      await sendMessage(chatId, "‚ùå Unknown state. Please start over with /start");
      await clearUserState(userId);
      break;
  }
}

async function handleStartCommand(chatId: number, userId: number): Promise<void> {
  // Check if user already has trading preferences set up
  const userPrefs = await getUserPreferences(userId);
  if (userPrefs && userPrefs.tradingMode) {
    // User already has a trading mode set up
    const modeInfo = getTradingModeInfo(userPrefs.tradingMode);
    const message = `
ü§ñ **Welcome back to Professional AI Trading Bot**

You're all set up with **${userPrefs.tradingMode}** trading mode!

${modeInfo}

üí∞ **Current Settings:**
‚Ä¢ Risk per trade: ${userPrefs.riskPercentage}%
‚Ä¢ Account balance: ${userPrefs.accountBalance ? `$${userPrefs.accountBalance.toLocaleString()}` : 'Not set'}
‚Ä¢ Account currency: ${userPrefs.accountCurrency}

üöÄ **Ready to Trade:**
‚Ä¢ Use \`/predict SYMBOL\` for analysis with your preferred mode
‚Ä¢ Use \`/scalping SYMBOL\`, \`/intraday SYMBOL\`, or \`/swing SYMBOL\` for specific strategies
‚Ä¢ Use \`/settings\` to change your trading preferences

üí° **Quick Start:** Try \`/${userPrefs.tradingMode.toLowerCase()} BTCUSD\` for a signal!
    `;
    const keyboard = createInlineKeyboard([
      [
        { text: `${userPrefs.tradingMode === 'SCALPING' ? '‚ö°' : userPrefs.tradingMode === 'INTRADAY' ? 'üìà' : 'üéØ'} ${userPrefs.tradingMode} BTCUSD`, callback_data: `strategy_${userPrefs.tradingMode}_BTCUSD` }
      ],
      [
        { text: "‚öôÔ∏è Settings", callback_data: "show_settings" },
        { text: "üìä Performance", callback_data: "show_performance" }
      ],
      [
        { text: "‚ùì Help", callback_data: "show_help" },
        { text: "üñ•Ô∏è VPS Setup", callback_data: "vps_setup" }
      ]
    ]);
    await sendMessage(chatId, message, { replyMarkup: keyboard });
  }
  else {
    // New user - need to set up trading mode
    await startTradingModeSetup(chatId, userId);
  }
}

async function startTradingModeSetup(chatId: number, userId: number): Promise<void> {
  await setUserState(userId, chatId, USER_STATES.SELECTING_TRADING_MODE);
  const message = `
üéØ **Welcome to Professional AI Trading Bot!**

Let's set up your trading preferences to get started.

**Step 1: Choose Your Trading Mode**

${getAllTradingModesInfo()}

ü§î **Which trading style fits you best?**

Select a mode below to see detailed information and continue setup:
  `;
  const keyboard = createInlineKeyboard([
    [
      { text: "‚ö° Scalping", callback_data: "mode_SCALPING" },
      { text: "üìà Intraday", callback_data: "mode_INTRADAY" },
      { text: "üéØ Swing", callback_data: "mode_SWING" }
    ],
    [
      { text: "‚ùì Help Me Choose", callback_data: "show_strategies" }
    ]
  ]);
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handleTradingModeSelection(chatId: number, userId: number, mode: TradingStrategy): Promise<void> {
  const userState = await getUserState(userId);
  if (!userState || userState.currentState !== USER_STATES.SELECTING_TRADING_MODE) {
    await sendMessage(chatId, "‚ùå Please start the setup process with /start");
    return;
  }
  // Show detailed information about the selected mode
  const modeInfo = getTradingModeInfo(mode);
  const message = `
‚úÖ **${mode} Trading Mode Selected!**

${modeInfo}

**Step 2: Risk Management Setup**

Now let's configure your risk management settings.

üí∞ **How much do you want to risk per trade?**

Please enter your risk percentage (recommended: 1-3%):
‚Ä¢ Conservative: 1%
‚Ä¢ Balanced: 2% 
‚Ä¢ Aggressive: 3%

Type a number like: \`2\` (for 2%)
  `;
  // Store the selected mode and move to risk setting state
  await setUserState(userId, chatId, USER_STATES.SETTING_RISK_AMOUNT, { selectedMode: mode });
  await sendMessage(chatId, message);
}

async function handleRiskAmountInput(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const riskInput = text.trim().replace('%', '');
  const riskPercentage = parseFloat(riskInput);
  if (isNaN(riskPercentage) || riskPercentage < 0.1 || riskPercentage > 10) {
    await sendMessage(chatId, "‚ùå Please enter a valid risk percentage between 0.1% and 10%.\n\nExample: `2` (for 2%)");
    return;
  }
  const message = `
‚úÖ **Risk Management Set: ${riskPercentage}%**

**Step 3: Account Balance (Optional)**

To provide accurate position sizing recommendations, please enter your account balance.

üí∞ **What's your account balance?**

Examples:
‚Ä¢ \`1000\` (for $1,000)
‚Ä¢ \`5000\` (for $5,000)
‚Ä¢ \`skip\` (to set this later)

This helps calculate optimal lot sizes for your trades.
  `;
  await setUserState(userId, chatId, USER_STATES.SETTING_ACCOUNT_BALANCE, {
    ...userState.stateData,
    riskPercentage
  });
  await sendMessage(chatId, message);
}

async function handleAccountBalanceInput(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const input = text.toLowerCase().trim();
  let accountBalance;
  if (input !== 'skip') {
    const balanceInput = parseFloat(input);
    if (isNaN(balanceInput) || balanceInput < 100) {
      await sendMessage(chatId, "‚ùå Please enter a valid account balance (minimum $100) or type `skip`.\n\nExample: `1000` (for $1,000)");
      return;
    }
    accountBalance = balanceInput;
  }
  // Save user preferences
  const preferences: UserPreferences = {
    userId,
    chatId,
    tradingMode: userState.stateData.selectedMode,
    riskPercentage: userState.stateData.riskPercentage,
    accountBalance,
    accountCurrency: 'USD'
  };
  await setUserPreferences(preferences);
  await setUserState(userId, chatId, USER_STATES.READY_TO_TRADE);
  const modeInfo = getTradingModeInfo(preferences.tradingMode!);
  const message = `
üéâ **Setup Complete!**

Your trading preferences have been saved:

${modeInfo}

üí∞ **Your Settings:**
‚Ä¢ Risk per trade: ${preferences.riskPercentage}%
‚Ä¢ Account balance: ${accountBalance ? `$${accountBalance.toLocaleString()}` : 'Not set (can be set later)'}
‚Ä¢ Account currency: ${preferences.accountCurrency}

üöÄ **You're ready to trade!**

Try these commands:
‚Ä¢ \`/predict BTCUSD\` - Get a signal using your preferred mode
‚Ä¢ \`/${preferences.tradingMode!.toLowerCase()} EURUSD\` - Get a specific strategy signal
‚Ä¢ \`/settings\` - Change your preferences anytime

**Let's start with your first signal!** üéØ
  `;
  const keyboard = createInlineKeyboard([
    [
      { text: `${preferences.tradingMode === 'SCALPING' ? '‚ö°' : preferences.tradingMode === 'INTRADAY' ? 'üìà' : 'üéØ'} Get ${preferences.tradingMode} Signal`, callback_data: `strategy_${preferences.tradingMode}_BTCUSD` }
    ],
    [
      { text: "üìä View All Strategies", callback_data: "show_strategies" },
      { text: "‚öôÔ∏è Settings", callback_data: "show_settings" }
    ],
    [
      { text: "üñ•Ô∏è Setup VPS", callback_data: "vps_setup" },
      { text: "‚ùì Help", callback_data: "show_help" }
    ]
  ]);
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handleSettingsCommand(chatId: number, userId: number): Promise<void> {
  const userPrefs = await getUserPreferences(userId);
  if (!userPrefs) {
    await sendMessage(chatId, "‚ùå No preferences found. Please start with /start to set up your trading mode.");
    return;
  }
  const modeInfo = getTradingModeInfo(userPrefs.tradingMode!);
  const message = `
‚öôÔ∏è **Your Trading Settings**

${modeInfo}

üí∞ **Current Settings:**
‚Ä¢ Risk per trade: ${userPrefs.riskPercentage}%
‚Ä¢ Account balance: ${userPrefs.accountBalance ? `$${userPrefs.accountBalance.toLocaleString()}` : 'Not set'}
‚Ä¢ Account currency: ${userPrefs.accountCurrency}

üîß **Change Settings:**
Use \`/start\` to reconfigure your trading mode and risk settings.

üìä **Available Commands:**
‚Ä¢ \`/predict SYMBOL\` - Use your preferred mode (${userPrefs.tradingMode})
‚Ä¢ \`/scalping SYMBOL\` - Force scalping mode
‚Ä¢ \`/intraday SYMBOL\` - Force intraday mode  
‚Ä¢ \`/swing SYMBOL\` - Force swing mode
‚Ä¢ \`/performance\` - View your trading statistics
  `;
  const keyboard = createInlineKeyboard([
    [
      { text: "üîÑ Reconfigure", callback_data: "setup_trading_mode" },
      { text: "üìä Performance", callback_data: "show_performance" }
    ],
    [
      { text: "‚ùì Help", callback_data: "show_help" },
      { text: "üñ•Ô∏è VPS Setup", callback_data: "vps_setup" }
    ]
  ]);
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handlePredictCommand(chatId: number, command: string, userId?: number): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";
  try {
    const userPrefs = userId ? await getUserPreferences(userId) : null;
    const strategy = userPrefs?.tradingMode;
    const strategyText = strategy ? ` using your preferred ${strategy} mode` : "";
    await sendMessage(chatId, `üß† **Advanced ML Analysis for ${symbol}**${strategyText}\n\nüîç Analyzing market structure, smart money flow, and determining optimal strategy...\n\n‚è≥ This may take 10-15 seconds for comprehensive analysis.`);
    const prediction = await predict({
      symbol,
      strategy
    });
    await sendTradingSignal(chatId, prediction, userPrefs);
  }
  catch (error) {
    console.error("Prediction error:", error);
    await sendMessage(chatId, "‚ùå Error generating prediction. Please try again or check if the symbol is valid.");
  }
}

async function handleStrategyCommand(chatId: number, command: string, strategy: "SCALPING" | "INTRADAY" | "SWING", userId?: number): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";
  try {
    const userPrefs = userId ? await getUserPreferences(userId) : null;
    const strategyEmojis = {
      "SCALPING": "‚ö°",
      "INTRADAY": "üìà",
      "SWING": "üéØ"
    };
    await sendMessage(chatId, `${strategyEmojis[strategy]} **${strategy} Analysis for ${symbol}**\n\nüîç Analyzing market for ${strategy.toLowerCase()} opportunities...\n\n‚è≥ Optimizing entry, stop loss, and take profit levels...`);
    const prediction = await predict({
      symbol,
      strategy: strategy
    });
    await sendTradingSignal(chatId, prediction, userPrefs);
  }
  catch (error) {
    console.error("Strategy prediction error:", error);
    await sendMessage(chatId, `‚ùå Error generating ${strategy.toLowerCase()} analysis. Please try again.`);
  }
}

async function sendTradingSignal(chatId: number, prediction: any, userPrefs?: UserPreferences | null): Promise<void> {
  const strategyEmojis: Record<string, string> = {
    "SCALPING": "‚ö°",
    "INTRADAY": "üìà",
    "SWING": "üéØ"
  };

  const confidenceEmoji = prediction.confidence >= 85 ? "üî•" : prediction.confidence >= 75 ? "‚ö°" : "‚ö†Ô∏è";
  const strategyEmoji = strategyEmojis[prediction.strategy] || "üìä";
  
  // Calculate position size based on user preferences
  let positionSizeInfo = "";
  if (userPrefs && userPrefs.accountBalance && userPrefs.riskPercentage) {
    const riskAmount = userPrefs.accountBalance * (userPrefs.riskPercentage / 100);
    const stopLossDistance = Math.abs(prediction.entryPrice - prediction.stopLoss);
    const suggestedLotSize = Math.min(riskAmount / stopLossDistance, 2.0); // Max 2 lots
    
    positionSizeInfo = `

üéØ **Your Position Sizing:**
‚Ä¢ Account Balance: $${userPrefs.accountBalance.toLocaleString()}
‚Ä¢ Risk Amount: $${riskAmount.toFixed(2)} (${userPrefs.riskPercentage}%)
‚Ä¢ Suggested Lot Size: ${Math.round(suggestedLotSize * 100) / 100} lots`;
  }
  
  const message = `
${strategyEmoji} **${prediction.strategy} Signal - ${prediction.symbol}**

üÜî **Trade ID:** \`${prediction.tradeId}\`
üìà **Direction:** **${prediction.direction}**
üí∞ **Entry Price:** ${prediction.entryPrice}
üéØ **Take Profit:** ${prediction.takeProfit}
üõ°Ô∏è **Stop Loss:** ${prediction.stopLoss}
${confidenceEmoji} **Confidence:** **${prediction.confidence}%**
üìä **Risk/Reward:** 1:${prediction.riskRewardRatio}
üíé **Recommended Size:** ${prediction.recommendedLotSize} lots
‚è±Ô∏è **Max Hold Time:** ${prediction.maxHoldingTime}h${positionSizeInfo}

üìä **Strategy Analysis:**
${prediction.strategyRecommendation}

üß† **AI Technical Analysis:**
‚Ä¢ **Trend:** ${prediction.analysis?.priceAction?.trend || 'N/A'}
‚Ä¢ **Support:** ${prediction.analysis?.support || 'N/A'}
‚Ä¢ **Resistance:** ${prediction.analysis?.resistance || 'N/A'}
‚Ä¢ **Smart Money:** ${prediction.analysis?.smartMoney?.institutionalFlow || 'N/A'}

üí° **Risk Management:**
Always use stop loss and never risk more than 2% of your account per trade.
  `;
    // Create inline keyboard for quick actions
    const suggestedSize = userPrefs && userPrefs.accountBalance ?
        Math.min(userPrefs.accountBalance * (userPrefs.riskPercentage || 2) / 100 / Math.abs(prediction.entryPrice - prediction.stopLoss), 2.0) :
        prediction.recommendedLotSize;
    const keyboard = createInlineKeyboard([
        [
            { text: `${strategyEmoji} Execute ${Math.round(suggestedSize * 100) / 100}`, callback_data: `execute_${prediction.tradeId}_${Math.round(suggestedSize * 100) / 100}_${prediction.strategy}` },
            { text: `${strategyEmoji} Execute 0.01`, callback_data: `execute_${prediction.tradeId}_0.01_${prediction.strategy}` }
        ],
        [
            { text: "üìä New Analysis", callback_data: "new_analysis" },
            { text: "üìà Performance", callback_data: "show_performance" }
        ]
    ]);
    await sendMessage(chatId, message, { replyMarkup: keyboard });
}

// Simplified versions of remaining handler functions
async function handleExecuteCommand(chatId: number, command: string): Promise<void> {
  const parts = command.split(" ");
  if (parts.length < 3) {
    await sendMessage(chatId, "‚ùå Usage: `/execute TRADE_ID LOT_SIZE`\n\nExample: `/execute BTC-001 0.1`");
    return;
  }
  const tradeId = parts[1];
  const lotSize = parseFloat(parts[2]);
  const strategy = parts[3] || "INTRADAY";
  if (isNaN(lotSize) || lotSize <= 0) {
    await sendMessage(chatId, "‚ùå Invalid lot size. Please use a positive number.\n\nExample: `/execute BTC-001 0.1`");
    return;
  }
  await executeTradeFromCallback(chatId, tradeId, lotSize, strategy);
}

async function handleHelpCommand(chatId: number): Promise<void> {
  const message = `
ü§ñ **Professional AI Trading Bot - Help**

**üéØ Trading Commands:**
‚Ä¢ \`/predict SYMBOL\` - AI analysis with optimal strategy
‚Ä¢ \`/scalping SYMBOL\` - Quick trades (1-15 min)
‚Ä¢ \`/intraday SYMBOL\` - Day trading (1-8 hours)
‚Ä¢ \`/swing SYMBOL\` - Multi-day trades (1-7 days)
‚Ä¢ \`/execute TRADE_ID LOT_SIZE\` - Execute trade on MT5

**üñ•Ô∏è VPS Management:**
‚Ä¢ \`/vps\` - VPS dashboard and status
‚Ä¢ \`/vps_setup\` - Configure VPS automatically

**üí∞ Account & Subscription:**
‚Ä¢ \`/subscription\` - View your subscription details
‚Ä¢ \`/features\` - See your available features
‚Ä¢ \`/upgrade\` - Upgrade your plan
‚Ä¢ \`/support\` - Get help and support

**üìä Information Commands:**
‚Ä¢ \`/status\` - Bot and MT5 connection status
‚Ä¢ \`/performance\` - Trading statistics
‚Ä¢ \`/settings\` - Your trading preferences
‚Ä¢ \`/strategies\` - Learn about strategies
‚Ä¢ \`/symbols\` - Supported trading symbols

**üí° Pro Tips:**
‚Ä¢ Start with \`/vps_setup\` for automated configuration
‚Ä¢ Use your preferred trading mode from \`/settings\`
‚Ä¢ Always follow risk management guidelines

**‚ö†Ô∏è Risk Warning:**
This bot uses advanced AI analysis. Always use proper risk management and never trade money you can't afford to lose.

Need more help? Check \`/subscription\` for your plan details! üí¨
  `;
  await sendMessage(chatId, message);
}

async function handleStatusCommand(chatId: number): Promise<void> {
  const message = `
üîß **Professional Trading System Status**

üß† **ML Engine:** ‚úÖ Online (Advanced Models Active)
ü§ñ **Gemini AI:** ‚úÖ Connected (Professional Analysis)
üìä **Smart Money Tracker:** ‚úÖ Active (Institutional Flow)
üìà **Order Flow Analyzer:** ‚úÖ Streaming (Real-time)
üì∞ **News Sentiment:** ‚úÖ Active (Multi-source)
‚ö° **MT5 Bridge:** ‚úÖ Connected (Professional Execution)
üñ•Ô∏è **VPS Manager:** ‚úÖ Active (24/7 Monitoring)

üí∞ **Account Info:**
‚Ä¢ Balance: $10,000.00
‚Ä¢ Free Margin: $9,500.00
‚Ä¢ Open Positions: 0
‚Ä¢ Risk Level: Conservative

üéØ **Strategy Capabilities:**
‚Ä¢ ‚ö° Scalping: ‚úÖ Active (1-15 min trades)
‚Ä¢ üìà Intraday: ‚úÖ Active (1-8 hour trades)
‚Ä¢ üéØ Swing: ‚úÖ Active (1-7 day trades)

**System Status:** üü¢ All systems operational
  `;
  await sendMessage(chatId, message);
}

async function handlePerformanceCommand(chatId: number): Promise<void> {
  try {
    const performance = await getPerformance();
    const message = `
üìä **Trading Performance Dashboard**

**üéØ Overall Statistics:**
‚Ä¢ Total Trades: ${performance.totalTrades}
‚Ä¢ Win Rate: ${performance.winRate.toFixed(1)}%
‚Ä¢ Average Profit: $${performance.avgProfit.toFixed(2)}
‚Ä¢ Average Loss: $${performance.avgLoss.toFixed(2)}

**üìà Best Performance:**
‚Ä¢ Best Trade: $${performance.bestTrade.toFixed(2)}
‚Ä¢ Profit Factor: ${performance.profitFactor.toFixed(2)}
‚Ä¢ Average Confidence: ${performance.avgConfidence.toFixed(1)}%

**‚ö†Ô∏è Risk Metrics:**
‚Ä¢ Worst Trade: $${performance.worstTrade.toFixed(2)}

**üí° Keep up the excellent work!**
Trading performance is looking strong. Remember to always follow proper risk management principles.

üìà **Next Steps:**
‚Ä¢ Continue following your trading plan
‚Ä¢ Use \`/predict SYMBOL\` for new signals
‚Ä¢ Check \`/status\` for system health
    `;
    await sendMessage(chatId, message);
  }
  catch (error) {
    console.error("Error getting performance:", error);
    await sendMessage(chatId, "‚ùå Error retrieving performance data. Please try again.");
  }
}

async function handleSymbolsCommand(chatId: number): Promise<void> {
  const message = `
üìä **Supported Trading Symbols**

**üí∞ Major Forex Pairs:**
‚Ä¢ **EURUSD** - Euro/US Dollar ‚ö°üìàüéØ
‚Ä¢ **GBPUSD** - British Pound/US Dollar ‚ö°üìàüéØ
‚Ä¢ **USDJPY** - US Dollar/Japanese Yen ‚ö°üìàüéØ
‚Ä¢ **AUDUSD** - Australian Dollar/US Dollar üìàüéØ
‚Ä¢ **USDCAD** - US Dollar/Canadian Dollar üìàüéØ
‚Ä¢ **USDCHF** - US Dollar/Swiss Franc üìàüéØ
‚Ä¢ **NZDUSD** - New Zealand Dollar/US Dollar üìàüéØ

**üíé Cryptocurrencies:**
‚Ä¢ **BTCUSD** - Bitcoin ‚ö°üìàüéØ
‚Ä¢ **ETHUSD** - Ethereum ‚ö°üìàüéØ

**üèÜ Precious Metals:**
‚Ä¢ **XAUUSD** - Gold üìàüéØ

**üõ¢Ô∏è Commodities:**
‚Ä¢ **CRUDE** - WTI Oil üìàüéØ
‚Ä¢ **BRENT** - Brent Oil üìàüéØ

**üéØ Strategy Symbols:**
‚ö° = Excellent for SCALPING (1-15 min)
üìà = Excellent for INTRADAY (1-8 hours)  
üéØ = Excellent for SWING (1-7 days)

**Usage Examples:**
‚Ä¢ \`/scalping BTCUSD\` - Bitcoin scalping
‚Ä¢ \`/intraday EURUSD\` - Euro intraday
‚Ä¢ \`/swing XAUUSD\` - Gold swing trading
  `;
  await sendMessage(chatId, message);
}

async function handleStrategiesCommand(chatId: number): Promise<void> {
  const message = `
üìä **Trading Strategies Guide**

${getAllTradingModesInfo()}

**üéØ How to Choose:**

**Choose SCALPING if:**
‚Ä¢ You can monitor trades actively
‚Ä¢ You prefer quick profits
‚Ä¢ You have a stable internet connection
‚Ä¢ You like high-frequency trading

**Choose INTRADAY if:**
‚Ä¢ You trade part-time
‚Ä¢ You want balanced risk/reward
‚Ä¢ You can check trades 2-3 times daily
‚Ä¢ You prefer medium-term opportunities

**Choose SWING if:**
‚Ä¢ You're a busy professional
‚Ä¢ You prefer hands-off trading
‚Ä¢ You want larger profit targets
‚Ä¢ You can hold positions for days

**üí° Pro Tips:**
‚Ä¢ Use \`/settings\` to set your preferred mode
‚Ä¢ Start with INTRADAY for balanced approach
‚Ä¢ Combine strategies for diversification
‚Ä¢ Always follow risk management rules

Ready to start? Use \`/predict SYMBOL\` for analysis!
  `;
  await sendMessage(chatId, message);
}
