import { sendMessage, sendPhoto, createInlineKeyboard } from "./telegram-client";
import { predict } from "../analysis/predict";
import { execute } from "../analysis/execute";
import { getPerformance } from "../analysis/performance";
import { TradingStrategy } from "../analysis/trading-strategies";
import { handleVPSCommand, handleVPSSetup, handleVPSSetupCallback } from "./vps-manager";
import { handleClientCommands, checkClientFeature } from "./client-manager";
import { 
  getUserPreferences, 
  setUserPreferences, 
  getUserState, 
  setUserState, 
  clearUserState,
  USER_STATES,
  getTradingModeInfo,
  getAllTradingModesInfo,
  UserPreferences 
} from "./user-state-manager";

export async function processMessage(chatId: number, userId: number, text: string): Promise<void> {
  const command = text.toLowerCase().trim();

  try {
    // Check if user is in a state that requires specific handling
    const userState = await getUserState(userId);
    if (userState && userState.currentState !== USER_STATES.READY_TO_TRADE) {
      await handleUserStateFlow(chatId, userId, text, userState);
      return;
    }

    if (command.startsWith("/predict")) {
      // Check if user has signal access
      const hasAccess = await checkClientFeature(userId, "basic_signals") ||
                       await checkClientFeature(userId, "advanced_signals") ||
                       await checkClientFeature(userId, "premium_signals");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access AI signals. Use `/subscription` to learn more.");
        return;
      }
      
      await handlePredictCommand(chatId, command, userId);
    } else if (command.startsWith("/scalping")) {
      await handleStrategyCommand(chatId, command, "SCALPING", userId);
    } else if (command.startsWith("/intraday")) {
      await handleStrategyCommand(chatId, command, "INTRADAY", userId);
    } else if (command.startsWith("/swing")) {
      await handleStrategyCommand(chatId, command, "SWING", userId);
    } else if (command.startsWith("/execute")) {
      await handleExecuteCommand(chatId, command);
    } else if (command === "/start") {
      await handleStartCommand(chatId, userId);
    } else if (command === "/help") {
      await handleHelpCommand(chatId);
    } else if (command === "/status") {
      await handleStatusCommand(chatId);
    } else if (command === "/performance") {
      await handlePerformanceCommand(chatId);
    } else if (command.startsWith("/symbols")) {
      await handleSymbolsCommand(chatId);
    } else if (command.startsWith("/strategies")) {
      await handleStrategiesCommand(chatId);
    } else if (command.startsWith("/vps")) {
      // Check if user has VPS management access
      const hasAccess = await checkClientFeature(userId, "vps_management");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access VPS management. Use `/subscription` to learn more.");
        return;
      }
      
      await handleVPSCommand(chatId, userId, command);
    } else if (command === "/vps_setup") {
      // Check if user has VPS management access
      const hasAccess = await checkClientFeature(userId, "vps_management");
      
      if (!hasAccess) {
        await sendMessage(chatId, "‚ùå You need an active subscription to access VPS setup. Use `/subscription` to learn more.");
        return;
      }
      
      await handleVPSSetup(chatId, userId);
    } else if (command === "/vps_status") {
      await handleVPSCommand(chatId, userId, "/vps_status");
    } else if (command === "/vps_restart") {
      await handleVPSCommand(chatId, userId, "/vps_restart");
    } else if (command === "/vps_logs") {
      await handleVPSCommand(chatId, userId, "/vps_logs");
    } else if (command === "/subscription" || command === "/features" || command === "/upgrade" || command === "/support") {
      await handleClientCommands(chatId, userId, command);
    } else if (command === "/settings") {
      await handleSettingsCommand(chatId, userId);
    } else {
      // Check if user is in VPS setup mode by checking if they have an active state
      const userState = await getUserState(userId);
      if (userState && userState.currentState !== USER_STATES.READY_TO_TRADE) {
        await handleUserStateFlow(chatId, userId, text, userState);
      } else {
        // Default VPS setup handler for unrecognized commands
        await handleVPSSetup(chatId, userId, text);
      }
    }
  } catch (error) {
    console.error("Error processing message:", error);
    await sendMessage(chatId, "‚ùå Si √® verificato un errore durante l'elaborazione della tua richiesta. Riprova.");
  }
}

export async function processCallbackQuery(chatId: number, userId: number, callbackData: string): Promise<void> {
  try {
    if (callbackData.startsWith("vps_")) {
      await handleVPSSetupCallback(chatId, userId, callbackData);
    } else if (callbackData.startsWith("mode_")) {
      const mode = callbackData.replace("mode_", "") as TradingStrategy;
      await handleTradingModeSelection(chatId, userId, mode);
    } else if (callbackData.startsWith("execute_")) {
      const parts = callbackData.split("_");
      const tradeId = parts[1];
      const lotSize = parseFloat(parts[2]);
      const strategy = parts[3] || "INTRADAY";
      await executeTradeFromCallback(chatId, tradeId, lotSize, strategy);
    } else if (callbackData.startsWith("strategy_")) {
      const parts = callbackData.split("_");
      const strategy = parts[1] as "SCALPING" | "INTRADAY" | "SWING";
      const symbol = parts[2] || "BTCUSD";
      await handleStrategyCommand(chatId, `/predict ${symbol}`, strategy, userId);
    } else if (callbackData === "new_analysis") {
      await sendMessage(chatId, "üìä Choose your trading strategy:\n\n‚ö° `/scalping SYMBOL` - Quick trades (1-15 min)\nüìà `/intraday SYMBOL` - Day trading (1-8 hours)\nüéØ `/swing SYMBOL` - Multi-day trades (1-7 days)\n\nExample: `/scalping EURUSD`");
    } else if (callbackData === "show_performance") {
      await handlePerformanceCommand(chatId);
    } else if (callbackData.startsWith("predict_")) {
      const symbol = callbackData.replace("predict_", "");
      await handlePredictCommand(chatId, `/predict ${symbol}`, userId);
    } else if (callbackData === "show_help") {
      await handleHelpCommand(chatId);
    } else if (callbackData === "show_strategies") {
      await handleStrategiesCommand(chatId);
    } else if (callbackData === "setup_trading_mode") {
      await startTradingModeSetup(chatId, userId);
    } else if (callbackData === "show_settings") {
      await handleSettingsCommand(chatId, userId);
    } else if (callbackData === "vps_setup") {
      await handleVPSSetup(chatId, userId);
    }
  } catch (error) {
    console.error("Error processing callback query:", error);
    await sendMessage(chatId, "‚ùå Error processing your request. Please try again.");
  }
}

async function executeTradeFromCallback(chatId: number, tradeId: string, lotSize: number, strategy: string): Promise<void> {
  try {
    await sendMessage(chatId, `‚ö° Executing ${strategy} trade ${tradeId} with ${lotSize} lots...`);
    
    const result = await execute({ tradeId, lotSize, strategy: strategy as TradingStrategy });
    
    if (result.success) {
      const message = `
‚úÖ **${strategy} Trade Executed Successfully**

üÜî Trade ID: \`${tradeId}\`
üìã MT5 Order: #${result.orderId}
üí∞ Lot Size: ${lotSize}
üíµ Entry Price: ${result.executionPrice}
‚è±Ô∏è Estimated Hold: ${result.estimatedHoldingTime}

üéØ Your ${strategy.toLowerCase()} trade is now active on MT5!
      `;
      await sendMessage(chatId, message);
    } else {
      await sendMessage(chatId, `‚ùå **Trade execution failed**\n\nüö´ Error: ${result.error}\n\nPlease check your MT5 connection and try again.`);
    }
  } catch (error) {
    console.error("Execution error:", error);
    await sendMessage(chatId, "‚ùå Error executing trade. Please check your MT5 connection and try again.");
  }
}

async function handlePredictCommand(chatId: number, command: string): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";

  try {
    await sendMessage(chatId, `üß† **Advanced ML Analysis for ${symbol}**\n\nüîç Analyzing market structure, smart money flow, and determining optimal strategy...\n\n‚è≥ This may take 10-15 seconds for comprehensive analysis.`);
    
    const prediction = await predict({ symbol });
    
    await sendTradingSignal(chatId, prediction);
  } catch (error) {
    console.error("Prediction error:", error);
    await sendMessage(chatId, "‚ùå Errore nella generazione della previsione. Riprova o controlla se il simbolo √® valido.");
  }
}

async function handleStrategyCommand(chatId: number, command: string, strategy: "SCALPING" | "INTRADAY" | "SWING"): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";

  try {
    const strategyEmojis = {
      "SCALPING": "‚ö°",
      "INTRADAY": "üìà", 
      "SWING": "üéØ"
    };

    await sendMessage(chatId, `${strategyEmojis[strategy]} **${strategy} Analysis for ${symbol}**\n\nüîç Analyzing market for ${strategy.toLowerCase()} opportunities...\n\n‚è≥ Optimizing entry, stop loss, and take profit levels...`);
    
    const prediction = await predict({ symbol, strategy: strategy as TradingStrategy });
    
    await sendTradingSignal(chatId, prediction);
  } catch (error) {
    console.error("Strategy prediction error:", error);
    await sendMessage(chatId, `‚ùå Errore nella generazione dell'analisi ${strategy.toLowerCase()}. Riprova.`);
  }
}

async function sendTradingSignal(chatId: number, prediction: any): Promise<void> {
  const strategyEmojis: Record<string, string> = {
    "SCALPING": "‚ö°",
    "INTRADAY": "üìà",
    "SWING": "üéØ"
  };

  const directionEmoji = prediction.direction === "LONG" ? "üìà" : "üìâ";
  const confidenceEmoji = prediction.confidence >= 85 ? "üî•" : prediction.confidence >= 75 ? "‚ö°" : "‚ö†Ô∏è";
  const strategyEmoji = strategyEmojis[prediction.strategy] || "üìä";
  
  const message = `
${strategyEmoji} **${prediction.strategy} Signal - ${prediction.symbol}**

üÜî Trade ID: \`${prediction.tradeId}\`
${directionEmoji} **Direction: ${prediction.direction}**
üí∞ **Entry Price:** \`${prediction.entryPrice}\`
üéØ **Take Profit:** \`${prediction.takeProfit}\`
üõ°Ô∏è **Stop Loss:** \`${prediction.stopLoss}\`
${confidenceEmoji} **Confidence:** **${prediction.confidence}%**
üìä **Risk/Reward:** 1:${prediction.riskRewardRatio}
üíé **Recommended Size:** ${prediction.recommendedLotSize} lots
‚è±Ô∏è **Max Hold Time:** ${prediction.maxHoldingTime}h

üìä **Strategy Analysis:**
${prediction.strategyRecommendation}

üìà **Price Action Analysis:**
‚Ä¢ Market Structure: **${prediction.analysis.technical.structure}**
‚Ä¢ Trend: **${prediction.analysis.technical.trend}**
‚Ä¢ Breakout Probability: **${prediction.analysis.technical.breakoutProbability}%**

üë• **Professional Trader Consensus:**
‚Ä¢ Top Traders: ${prediction.analysis.professional.topTraders.slice(0, 2).join(", ")}
‚Ä¢ Consensus: **${prediction.analysis.professional.consensusView}**
‚Ä¢ Risk/Reward: **1:${prediction.analysis.professional.riskReward.toFixed(1)}**

üéØ **Key Liquidity Zones:**
${prediction.analysis.smartMoney.liquidityZones.slice(0, 3).map((zone: number) => `‚Ä¢ ${zone.toFixed(5)}`).join('\n')}

üì∞ **Market Sentiment:** ${getSentimentEmoji(prediction.analysis.sentiment.score)} ${(prediction.analysis.sentiment.score * 100).toFixed(0)}%

‚ö° **Quick Execute:**
\`/execute ${prediction.tradeId} ${prediction.recommendedLotSize}\`
  `;

  // Create inline keyboard for quick actions
  const keyboard = createInlineKeyboard([
    [
      { text: `${strategyEmoji} Execute ${prediction.recommendedLotSize}`, callback_data: `execute_${prediction.tradeId}_${prediction.recommendedLotSize}_${prediction.strategy}` },
      { text: `${strategyEmoji} Execute 0.01`, callback_data: `execute_${prediction.tradeId}_0.01_${prediction.strategy}` }
    ],
    [
      { text: "‚ö° Scalping", callback_data: `strategy_SCALPING_${prediction.symbol}` },
      { text: "üìà Intraday", callback_data: `strategy_INTRADAY_${prediction.symbol}` },
      { text: "üéØ Swing", callback_data: `strategy_SWING_${prediction.symbol}` }
    ],
    [
      { text: "üìä Nuova Analisi", callback_data: "new_analysis" },
      { text: "üìà Performance", callback_data: "show_performance" }
    ]
  ]);

  await sendMessage(chatId, message, { replyMarkup: keyboard });

  // Send chart image if available
  if (prediction.chartUrl) {
    try {
      await sendPhoto(chatId, prediction.chartUrl, `üìä ${prediction.strategy} Chart Analysis for ${prediction.symbol}`);
    } catch (error) {
      console.error("Error sending chart:", error);
      await sendMessage(chatId, `üìä Chart: ${prediction.chartUrl}`);
    }
  }
}

async function handleExecuteCommand(chatId: number, command: string): Promise<void> {
  const parts = command.split(" ");
  const tradeId = parts[1];
  const lotSize = parseFloat(parts[2] || "0.1");
  const strategy = parts[3] || "INTRADAY";

  if (!tradeId) {
    await sendMessage(chatId, "‚ùå Please provide a trade ID. Usage: `/execute TRADE_ID LOT_SIZE [STRATEGY]`");
    return;
  }

  if (isNaN(lotSize) || lotSize <= 0) {
    await sendMessage(chatId, "‚ùå Please provide a valid lot size. Usage: `/execute TRADE_ID LOT_SIZE [STRATEGY]`");
    return;
  }

  try {
    await sendMessage(chatId, `‚ö° Executing ${strategy} trade ${tradeId} with ${lotSize} lots...`);
    
    const result = await execute({ tradeId, lotSize, strategy: strategy as TradingStrategy });
    
    if (result.success) {
      const message = `
‚úÖ **${strategy} Trade Executed Successfully**

üÜî Trade ID: \`${tradeId}\`
üìã MT5 Order: #${result.orderId}
üí∞ Lot Size: ${lotSize}
üíµ Entry Price: ${result.executionPrice}
‚è±Ô∏è Estimated Hold: ${result.estimatedHoldingTime}

üéØ Your ${strategy.toLowerCase()} trade is now active on MT5!
      `;
      await sendMessage(chatId, message);
    } else {
      await sendMessage(chatId, `‚ùå **Trade execution failed**\n\nüö´ Error: ${result.error}\n\nPlease check your MT5 connection and try again.`);
    }
  } catch (error) {
    console.error("Execution error:", error);
    await sendMessage(chatId, "‚ùå Error executing trade. Please check your MT5 connection and try again.");
  }
}

async function handleStartCommand(chatId: number): Promise<void> {
  const message = `
ü§ñ **Welcome to Professional AI Trading Bot**

I'm your institutional-grade trading assistant with **3 specialized strategies**! 

üß† **What Makes Me Different:**
‚Ä¢ **Smart Money Analysis** - Track institutional flow and order patterns
‚Ä¢ **Professional Trader Consensus** - Follow top traders for each asset
‚Ä¢ **Advanced Price Action** - Market structure and liquidity zone analysis
‚Ä¢ **ML-Powered Predictions** - No traditional indicators, pure price action

‚ö° **Trading Strategies:**
‚Ä¢ \`/scalping SYMBOL\` - Quick trades (1-15 minutes, tight stops)
‚Ä¢ \`/intraday SYMBOL\` - Day trading (1-8 hours, balanced risk)
‚Ä¢ \`/swing SYMBOL\` - Multi-day trades (1-7 days, larger targets)

üìä **General Analysis:**
‚Ä¢ \`/predict SYMBOL\` - Auto-select optimal strategy

‚ö° **Execution Commands:**
‚Ä¢ \`/execute TRADE_ID LOT_SIZE [STRATEGY]\` - Execute trade on MT5

üñ•Ô∏è **VPS Management:**
‚Ä¢ \`/vps\` - Manage your VPS and MT5 setup
‚Ä¢ \`/vps_setup\` - Configure new VPS automatically

üìà **Information Commands:**
‚Ä¢ \`/status\` - Check bot and MT5 status
‚Ä¢ \`/performance\` - View trading performance
‚Ä¢ \`/strategies\` - Learn about trading strategies
‚Ä¢ \`/symbols\` - List supported symbols

üìö **Help:**
‚Ä¢ \`/help\` - Show detailed help

üöÄ **Quick Start:**
1. Use \`/vps_setup\` to configure your VPS and MT5
2. Try \`/scalping BTCUSD\` for a quick scalping signal!
3. Or \`/swing EURUSD\` for a swing trading opportunity!

üí° **Professional Tip:** Each strategy has optimized risk/reward ratios and holding times. Choose based on your trading style and available time.
  `;
  
  const keyboard = createInlineKeyboard([
    [
      { text: "‚ö° Scalping BTCUSD", callback_data: "strategy_SCALPING_BTCUSD" },
      { text: "üìà Intraday EURUSD", callback_data: "strategy_INTRADAY_EURUSD" }
    ],
    [
      { text: "üéØ Swing XAUUSD", callback_data: "strategy_SWING_XAUUSD" },
      { text: "üñ•Ô∏è Setup VPS", callback_data: "vps_setup" }
    ],
    [
      { text: "üìä Strategies Guide", callback_data: "show_strategies" },
      { text: "‚ùì Help", callback_data: "show_help" }
    ]
  ]);
  
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handleStrategiesCommand(chatId: number): Promise<void> {
  const message = `
üìä **Professional Trading Strategies Guide**

**‚ö° SCALPING STRATEGY**
‚Ä¢ **Timeframe:** 1-15 minutes
‚Ä¢ **Risk/Reward:** 1:1.5
‚Ä¢ **Best For:** Quick profits, high-volume sessions
‚Ä¢ **Stop Loss:** Tight (0.8x ATR)
‚Ä¢ **Take Profit:** Quick (1.2x ATR)
‚Ä¢ **Min Confidence:** 85%
‚Ä¢ **Max Position:** 0.5 lots
‚Ä¢ **Ideal Conditions:** High volume, trending markets, low spreads

**üìà INTRADAY STRATEGY**
‚Ä¢ **Timeframe:** 1-8 hours
‚Ä¢ **Risk/Reward:** 1:2.0
‚Ä¢ **Best For:** Day trading, balanced approach
‚Ä¢ **Stop Loss:** Standard (1.0x ATR)
‚Ä¢ **Take Profit:** Standard (2.0x ATR)
‚Ä¢ **Min Confidence:** 75%
‚Ä¢ **Max Position:** 1.0 lots
‚Ä¢ **Ideal Conditions:** Normal volume, trending markets, breakouts

**üéØ SWING STRATEGY**
‚Ä¢ **Timeframe:** 1-7 days
‚Ä¢ **Risk/Reward:** 1:3.0
‚Ä¢ **Best For:** Multi-day trends, larger moves
‚Ä¢ **Stop Loss:** Wide (1.5x ATR)
‚Ä¢ **Take Profit:** Large (4.5x ATR)
‚Ä¢ **Min Confidence:** 70%
‚Ä¢ **Max Position:** 2.0 lots
‚Ä¢ **Ideal Conditions:** Any volume, reversals, consolidations

**üéì How to Choose:**

**Choose SCALPING when:**
‚Ä¢ You can monitor trades actively
‚Ä¢ Market is trending with high volume
‚Ä¢ You want quick profits
‚Ä¢ Low volatility environment

**Choose INTRADAY when:**
‚Ä¢ You trade during market hours
‚Ä¢ Balanced risk/reward approach
‚Ä¢ Following daily trends
‚Ä¢ Normal market conditions

**Choose SWING when:**
‚Ä¢ You prefer less monitoring
‚Ä¢ Looking for larger moves
‚Ä¢ Multi-day trend following
‚Ä¢ Higher volatility acceptable

**üí° Pro Tips:**
‚Ä¢ Start with INTRADAY for balanced approach
‚Ä¢ Use SCALPING during high-volume sessions
‚Ä¢ Use SWING for major trend reversals
‚Ä¢ Always respect the strategy's risk limits

**‚ö° Quick Commands:**
‚Ä¢ \`/scalping EURUSD\` - Generate scalping signal
‚Ä¢ \`/intraday GBPUSD\` - Generate intraday signal  
‚Ä¢ \`/swing XAUUSD\` - Generate swing signal
‚Ä¢ \`/predict BTCUSD\` - Auto-select best strategy

Each strategy is optimized for different market conditions and trading styles! üöÄ
  `;
  
  await sendMessage(chatId, message);
}

async function handleHelpCommand(chatId: number): Promise<void> {
  const message = `
üìö **Professional AI Trading Bot - Complete Guide**

**‚ö° SCALPING Commands:**
‚Ä¢ \`/scalping BTCUSD\` - Quick Bitcoin scalp (1-15 min)
‚Ä¢ \`/scalping EURUSD\` - Euro scalping opportunity
‚Ä¢ \`/scalping XAUUSD\` - Gold scalping signal

**üìà INTRADAY Commands:**
‚Ä¢ \`/intraday EURUSD\` - Euro day trading (1-8 hours)
‚Ä¢ \`/intraday GBPUSD\` - Pound intraday analysis
‚Ä¢ \`/intraday CRUDE\` - Oil day trading signal

**üéØ SWING Commands:**
‚Ä¢ \`/swing BTCUSD\` - Bitcoin swing trade (1-7 days)
‚Ä¢ \`/swing XAUUSD\` - Gold swing opportunity
‚Ä¢ \`/swing CRUDE\` - Oil swing analysis

**üìä General Analysis:**
‚Ä¢ \`/predict SYMBOL\` - Auto-select optimal strategy
‚Ä¢ \`/predict\` - Analyze BTCUSD (default)

**‚ö° Execution Commands:**
‚Ä¢ \`/execute BTC-001 0.1\` - Execute with 0.1 lots
‚Ä¢ \`/execute EUR-002 0.05 SCALPING\` - Execute scalping trade
‚Ä¢ \`/execute XAU-003 0.2 SWING\` - Execute swing trade

**üñ•Ô∏è VPS Management:**
‚Ä¢ \`/vps\` - VPS dashboard and management
‚Ä¢ \`/vps_setup\` - Automatic VPS configuration
‚Ä¢ \`/vps_status\` - Check VPS and MT5 status
‚Ä¢ \`/vps_restart\` - Restart trading bot on VPS
‚Ä¢ \`/vps_logs\` - View recent VPS logs

**üìä Information Commands:**
‚Ä¢ \`/status\` - Bot and MT5 connection status
‚Ä¢ \`/performance\` - Trading statistics
‚Ä¢ \`/strategies\` - Detailed strategy guide
‚Ä¢ \`/symbols\` - All supported trading symbols

**üéØ Strategy Features:**

**‚ö° SCALPING (1-15 min):**
‚Ä¢ Tight stops for capital protection
‚Ä¢ Quick profit taking
‚Ä¢ High confidence signals only
‚Ä¢ Best during high volume sessions

**üìà INTRADAY (1-8 hours):**
‚Ä¢ Balanced risk/reward ratio
‚Ä¢ Follow trend direction
‚Ä¢ Close before market close
‚Ä¢ Monitor news and events

**üéØ SWING (1-7 days):**
‚Ä¢ Wider stops for volatility
‚Ä¢ Larger profit targets
‚Ä¢ Less frequent monitoring
‚Ä¢ Focus on weekly trends

**üí° Professional Tips:**
‚Ä¢ **Risk Management:** Never risk more than 2% per trade
‚Ä¢ **Strategy Selection:** Choose based on available time and market conditions
‚Ä¢ **Position Sizing:** Use recommended lot sizes for optimal risk
‚Ä¢ **Monitoring:** Scalping requires active monitoring, swing allows passive approach

**‚ö†Ô∏è Risk Warning:**
This bot uses advanced institutional trading concepts. Always use proper risk management and never trade money you can't afford to lose.

Need more help? Try the specific strategy commands! üí¨
  `;
  
  await sendMessage(chatId, message);
}

async function handleStatusCommand(chatId: number): Promise<void> {
  try {
    // This would check actual system status
    const message = `
üîß **Professional Trading System Status**

üß† **ML Engine:** ‚úÖ Online (Advanced Models Active)
ü§ñ **Gemini AI:** ‚úÖ Connected (Professional Analysis)
üìä **Smart Money Tracker:** ‚úÖ Active (Institutional Flow)
üìà **Order Flow Analyzer:** ‚úÖ Streaming (Real-time)
üì∞ **News Sentiment:** ‚úÖ Active (Multi-source)
‚ö° **MT5 Bridge:** ‚úÖ Connected (Professional Execution)
üñ•Ô∏è **VPS Manager:** ‚úÖ Active (24/7 Monitoring)

üí∞ **Account Info:**
‚Ä¢ Balance: $10,000.00
‚Ä¢ Free Margin: $9,500.00
‚Ä¢ Open Positions: 0
‚Ä¢ Risk Level: Conservative

üéØ **Strategy Capabilities:**
‚Ä¢ ‚ö° Scalping: ‚úÖ Active (1-15 min trades)
‚Ä¢ üìà Intraday: ‚úÖ Active (1-8 hour trades)
‚Ä¢ üéØ Swing: ‚úÖ Active (1-7 day trades)
‚Ä¢ üìä Auto-Strategy: ‚úÖ Active (Optimal selection)

üïê **Last Update:** ${new Date().toLocaleString()}

All professional trading systems operational! üöÄ

Use \`/vps\` to manage your VPS and MT5 connection.
    `;
    
    await sendMessage(chatId, message);
  } catch (error) {
    console.error("Status check error:", error);
    await sendMessage(chatId, "‚ùå Error checking system status. Please try again.");
  }
}

async function handlePerformanceCommand(chatId: number): Promise<void> {
  try {
    const performance = await getPerformance();
    
    const winRateEmoji = performance.winRate >= 70 ? "üî•" : performance.winRate >= 50 ? "‚ö°" : "‚ö†Ô∏è";
    const profitFactorEmoji = performance.profitFactor >= 2 ? "üî•" : performance.profitFactor >= 1 ? "‚ö°" : "‚ö†Ô∏è";
    
    const message = `
üìä **Professional Trading Performance**

${winRateEmoji} **Win Rate:** ${performance.winRate.toFixed(1)}%
${profitFactorEmoji} **Profit Factor:** ${performance.profitFactor.toFixed(2)}
üìà **Total Signals:** ${performance.totalTrades}
üí∞ **Avg Profit:** $${performance.avgProfit.toFixed(2)}
üìâ **Avg Loss:** $${performance.avgLoss.toFixed(2)}
üéØ **Best Trade:** $${performance.bestTrade.toFixed(2)}
üìä **Avg Confidence:** ${performance.avgConfidence.toFixed(0)}%

**üß† ML Model Performance:**
${getMLPerformanceRating(performance.winRate, performance.profitFactor)}

**üìà Strategy Performance:**
‚Ä¢ ‚ö° Scalping: High frequency, tight risk management
‚Ä¢ üìà Intraday: Balanced approach, good for beginners
‚Ä¢ üéØ Swing: Larger moves, less monitoring required

**üéØ Professional Metrics:**
‚Ä¢ Risk/Reward Ratio: 1:${performance.profitFactor.toFixed(1)}
‚Ä¢ Sharpe Ratio: ${calculateSharpeRatio(performance)}
‚Ä¢ Maximum Drawdown: ${calculateMaxDrawdown(performance)}%
‚Ä¢ Recovery Factor: ${calculateRecoveryFactor(performance)}

**üöÄ Strategy Recommendations:**
‚Ä¢ Use **SCALPING** for quick profits during high volume
‚Ä¢ Use **INTRADAY** for balanced daily trading
‚Ä¢ Use **SWING** for larger moves with less monitoring

Keep following the smart money! üöÄ
    `;
    
    await sendMessage(chatId, message);
  } catch (error) {
    console.error("Performance error:", error);
    await sendMessage(chatId, "‚ùå Error retrieving performance data. Please try again.");
  }
}

async function handleSymbolsCommand(chatId: number): Promise<void> {
  const message = `
üìä **Supported Trading Symbols with Multi-Strategy Analysis**

**üí∞ Cryptocurrencies:**
‚Ä¢ **BTCUSD** - Bitcoin (All strategies: ‚ö°üìàüéØ)
‚Ä¢ **ETHUSD** - Ethereum (All strategies: ‚ö°üìàüéØ)

**üí± Major Forex Pairs:**
‚Ä¢ **EURUSD** - Euro/Dollar (Best for: ‚ö°üìà)
‚Ä¢ **GBPUSD** - Pound/Dollar (Best for: ‚ö°üìàüéØ)
‚Ä¢ **USDJPY** - Dollar/Yen (Best for: ‚ö°üìà)
‚Ä¢ **AUDUSD** - Australian Dollar (Best for: üìàüéØ)
‚Ä¢ **USDCAD** - Dollar/Canadian (Best for: üìàüéØ)
‚Ä¢ **USDCHF** - Dollar/Swiss Franc (Best for: üìàüéØ)

**ü•á Precious Metals:**
‚Ä¢ **XAUUSD** - Gold (Best for: üìàüéØ)

**üõ¢Ô∏è Commodities:**
‚Ä¢ **CRUDE** - WTI Oil (Best for: üìàüéØ)
‚Ä¢ **BRENT** - Brent Oil (Best for: üìàüéØ)

**üéØ Strategy Symbols:**
‚ö° = Excellent for SCALPING (1-15 min)
üìà = Excellent for INTRADAY (1-8 hours)  
üéØ = Excellent for SWING (1-7 days)

**Usage Examples:**
‚Ä¢ \`/scalping BTCUSD\` - Bitcoin scalping
‚Ä¢ \`/intraday EURUSD\` - Euro day trading
‚Ä¢ \`/swing XAUUSD\` - Gold swing trading
‚Ä¢ \`/predict GBPUSD\` - Auto-select best strategy

**üí° Strategy Selection Tips:**
‚Ä¢ **Crypto (BTC/ETH):** Great for all strategies due to 24/7 trading
‚Ä¢ **Major Forex:** Best for scalping and intraday during market hours
‚Ä¢ **Gold/Oil:** Excellent for swing trading due to larger moves
‚Ä¢ **Minor Pairs:** Better for intraday and swing strategies

More symbols and advanced features coming soon! üöÄ
  `;
  
  await sendMessage(chatId, message);
}

function getSentimentEmoji(score: number): string {
  if (score > 0.5) return "üî•";
  if (score > 0.2) return "üìà";
  if (score > -0.2) return "üòê";
  if (score > -0.5) return "üìâ";
  return "üî¥";
}

function getMLPerformanceRating(winRate: number, profitFactor: number): string {
  if (winRate >= 75 && profitFactor >= 2.5) {
    return "üî• **Exceptional** - Institutional-grade performance!";
  } else if (winRate >= 65 && profitFactor >= 2) {
    return "‚ö° **Professional** - High-quality ML predictions!";
  } else if (winRate >= 55 && profitFactor >= 1.5) {
    return "üìä **Good** - Solid machine learning results!";
  } else {
    return "‚ö†Ô∏è **Learning** - ML models adapting to market conditions.";
  }
}

function calculateSharpeRatio(performance: any): string {
  // Simplified Sharpe ratio calculation
  const avgReturn = performance.avgProfit * (performance.winRate / 100) + 
                   performance.avgLoss * ((100 - performance.winRate) / 100);
  const volatility = Math.abs(performance.avgProfit - performance.avgLoss);
  const sharpe = avgReturn / (volatility || 1);
  return sharpe.toFixed(2);
}

function calculateMaxDrawdown(performance: any): string {
  // Simplified max drawdown estimation
  const worstCase = Math.abs(performance.worstTrade);
  const avgProfit = performance.avgProfit;
  const drawdown = (worstCase / (avgProfit || 1)) * 100;
  return Math.min(50, drawdown).toFixed(1);
}

function calculateRecoveryFactor(performance: any): string {
  // Recovery factor = Total Profit / Max Drawdown
  const totalProfit = performance.avgProfit * performance.totalTrades * (performance.winRate / 100);
  const maxDrawdown = Math.abs(performance.worstTrade);
  const recovery = totalProfit / (maxDrawdown || 1);
  return recovery.toFixed(1);
}

// New functions for enhanced user experience and trading mode setup

async function handleUserStateFlow(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const command = text.toLowerCase().trim();
  
  switch (userState.currentState) {
    case USER_STATES.SETTING_RISK_AMOUNT:
      await handleRiskAmountInput(chatId, userId, text, userState);
      break;
      
    case USER_STATES.SETTING_ACCOUNT_BALANCE:
      await handleAccountBalanceInput(chatId, userId, text, userState);
      break;
      
    default:
      await sendMessage(chatId, "‚ùå Unknown state. Please start over with /start");
      await clearUserState(userId);
      break;
  }
}

async function handleStartCommand(chatId: number, userId: number): Promise<void> {
  // Check if user already has trading preferences set up
  const userPrefs = await getUserPreferences(userId);
  
  if (userPrefs && userPrefs.tradingMode) {
    // User already has a trading mode set up
    const modeInfo = getTradingModeInfo(userPrefs.tradingMode);
    
    const message = `
ü§ñ **Welcome back to Professional AI Trading Bot**

You're all set up with **${userPrefs.tradingMode}** trading mode!

${modeInfo}

üí∞ **Current Settings:**
‚Ä¢ Risk per trade: ${userPrefs.riskPercentage}%
‚Ä¢ Account balance: ${userPrefs.accountBalance ? `$${userPrefs.accountBalance.toLocaleString()}` : 'Not set'}
‚Ä¢ Account currency: ${userPrefs.accountCurrency}

üöÄ **Ready to Trade:**
‚Ä¢ Use \`/predict SYMBOL\` for analysis with your preferred mode
‚Ä¢ Use \`/scalping SYMBOL\`, \`/intraday SYMBOL\`, or \`/swing SYMBOL\` for specific strategies
‚Ä¢ Use \`/settings\` to change your trading preferences

üí° **Quick Start:** Try \`/${userPrefs.tradingMode.toLowerCase()} BTCUSD\` for a signal!
    `;
    
    const keyboard = createInlineKeyboard([
      [
        { text: `${userPrefs.tradingMode === 'SCALPING' ? '‚ö°' : userPrefs.tradingMode === 'INTRADAY' ? 'üìà' : 'üéØ'} ${userPrefs.tradingMode} BTCUSD`, callback_data: `strategy_${userPrefs.tradingMode}_BTCUSD` }
      ],
      [
        { text: "‚öôÔ∏è Settings", callback_data: "show_settings" },
        { text: "üìä Performance", callback_data: "show_performance" }
      ],
      [
        { text: "‚ùì Help", callback_data: "show_help" },
        { text: "üñ•Ô∏è VPS Setup", callback_data: "vps_setup" }
      ]
    ]);
    
    await sendMessage(chatId, message, { replyMarkup: keyboard });
    
  } else {
    // New user - need to set up trading mode
    await startTradingModeSetup(chatId, userId);
  }
}

async function startTradingModeSetup(chatId: number, userId: number): Promise<void> {
  await setUserState(userId, chatId, USER_STATES.SELECTING_TRADING_MODE);
  
  const message = `
üéØ **Welcome to Professional AI Trading Bot!**

Let's set up your trading preferences to get started.

**Step 1: Choose Your Trading Mode**

${getAllTradingModesInfo()}

ü§î **Which trading style fits you best?**

Select a mode below to see detailed information and continue setup:
  `;
  
  const keyboard = createInlineKeyboard([
    [
      { text: "‚ö° Scalping", callback_data: "mode_SCALPING" },
      { text: "üìà Intraday", callback_data: "mode_INTRADAY" },
      { text: "üéØ Swing", callback_data: "mode_SWING" }
    ],
    [
      { text: "‚ùì Help Me Choose", callback_data: "show_strategies" }
    ]
  ]);
  
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handleTradingModeSelection(chatId: number, userId: number, mode: TradingStrategy): Promise<void> {
  const userState = await getUserState(userId);
  if (!userState || userState.currentState !== USER_STATES.SELECTING_TRADING_MODE) {
    await sendMessage(chatId, "‚ùå Please start the setup process with /start");
    return;
  }
  
  // Show detailed information about the selected mode
  const modeInfo = getTradingModeInfo(mode);
  
  const message = `
‚úÖ **${mode} Trading Mode Selected!**

${modeInfo}

**Step 2: Risk Management Setup**

Now let's configure your risk management settings.

üí∞ **How much do you want to risk per trade?**

Please enter your risk percentage (recommended: 1-3%):
‚Ä¢ Conservative: 1%
‚Ä¢ Balanced: 2% 
‚Ä¢ Aggressive: 3%

Type a number like: \`2\` (for 2%)
  `;
  
  // Store the selected mode and move to risk setting state
  await setUserState(userId, chatId, USER_STATES.SETTING_RISK_AMOUNT, { selectedMode: mode });
  
  await sendMessage(chatId, message);
}

async function handleRiskAmountInput(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const riskInput = text.trim().replace('%', '');
  const riskPercentage = parseFloat(riskInput);
  
  if (isNaN(riskPercentage) || riskPercentage < 0.1 || riskPercentage > 10) {
    await sendMessage(chatId, "‚ùå Please enter a valid risk percentage between 0.1% and 10%.\n\nExample: `2` (for 2%)");
    return;
  }
  
  const message = `
‚úÖ **Risk Management Set: ${riskPercentage}%**

**Step 3: Account Balance (Optional)**

To provide accurate position sizing recommendations, please enter your account balance.

üí∞ **What's your account balance?**

Examples:
‚Ä¢ \`1000\` (for $1,000)
‚Ä¢ \`5000\` (for $5,000)
‚Ä¢ \`skip\` (to set this later)

This helps calculate optimal lot sizes for your trades.
  `;
  
  await setUserState(userId, chatId, USER_STATES.SETTING_ACCOUNT_BALANCE, {
    ...userState.stateData,
    riskPercentage
  });
  
  await sendMessage(chatId, message);
}

async function handleAccountBalanceInput(chatId: number, userId: number, text: string, userState: any): Promise<void> {
  const input = text.toLowerCase().trim();
  let accountBalance: number | undefined;
  
  if (input !== 'skip') {
    const balanceInput = parseFloat(input);
    if (isNaN(balanceInput) || balanceInput < 100) {
      await sendMessage(chatId, "‚ùå Please enter a valid account balance (minimum $100) or type `skip`.\n\nExample: `1000` (for $1,000)");
      return;
    }
    accountBalance = balanceInput;
  }
  
  // Save user preferences
  const preferences: UserPreferences = {
    userId,
    chatId,
    tradingMode: userState.stateData.selectedMode,
    riskPercentage: userState.stateData.riskPercentage,
    accountBalance,
    accountCurrency: 'USD'
  };
  
  await setUserPreferences(preferences);
  await setUserState(userId, chatId, USER_STATES.READY_TO_TRADE);
  
  const modeInfo = getTradingModeInfo(preferences.tradingMode!);
  
  const message = `
üéâ **Setup Complete!**

Your trading preferences have been saved:

${modeInfo}

üí∞ **Your Settings:**
‚Ä¢ Risk per trade: ${preferences.riskPercentage}%
‚Ä¢ Account balance: ${accountBalance ? `$${accountBalance.toLocaleString()}` : 'Not set (can be set later)'}
‚Ä¢ Account currency: ${preferences.accountCurrency}

üöÄ **You're ready to trade!**

Try these commands:
‚Ä¢ \`/predict BTCUSD\` - Get a signal using your preferred mode
‚Ä¢ \`/${preferences.tradingMode!.toLowerCase()} EURUSD\` - Get a specific strategy signal
‚Ä¢ \`/settings\` - Change your preferences anytime

**Let's start with your first signal!** üéØ
  `;
  
  const keyboard = createInlineKeyboard([
    [
      { text: `${preferences.tradingMode === 'SCALPING' ? '‚ö°' : preferences.tradingMode === 'INTRADAY' ? 'üìà' : 'üéØ'} Get ${preferences.tradingMode} Signal`, callback_data: `strategy_${preferences.tradingMode}_BTCUSD` }
    ],
    [
      { text: "üìä View All Strategies", callback_data: "show_strategies" },
      { text: "‚öôÔ∏è Settings", callback_data: "show_settings" }
    ],
    [
      { text: "üñ•Ô∏è Setup VPS", callback_data: "vps_setup" },
      { text: "‚ùì Help", callback_data: "show_help" }
    ]
  ]);
  
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handleSettingsCommand(chatId: number, userId: number): Promise<void> {
  const userPrefs = await getUserPreferences(userId);
  
  if (!userPrefs) {
    await sendMessage(chatId, "‚ùå No preferences found. Please start with /start to set up your trading mode.");
    return;
  }
  
  const modeInfo = getTradingModeInfo(userPrefs.tradingMode!);
  
  const message = `
‚öôÔ∏è **Your Trading Settings**

${modeInfo}

üí∞ **Current Settings:**
‚Ä¢ Risk per trade: ${userPrefs.riskPercentage}%
‚Ä¢ Account balance: ${userPrefs.accountBalance ? `$${userPrefs.accountBalance.toLocaleString()}` : 'Not set'}
‚Ä¢ Account currency: ${userPrefs.accountCurrency}

üîß **Change Settings:**
Use \`/start\` to reconfigure your trading mode and risk settings.

üìä **Available Commands:**
‚Ä¢ \`/predict SYMBOL\` - Use your preferred mode (${userPrefs.tradingMode})
‚Ä¢ \`/scalping SYMBOL\` - Force scalping mode
‚Ä¢ \`/intraday SYMBOL\` - Force intraday mode  
‚Ä¢ \`/swing SYMBOL\` - Force swing mode
‚Ä¢ \`/performance\` - View your trading statistics
  `;
  
  const keyboard = createInlineKeyboard([
    [
      { text: "üîÑ Reconfigure", callback_data: "setup_trading_mode" },
      { text: "üìä Performance", callback_data: "show_performance" }
    ],
    [
      { text: "‚ùì Help", callback_data: "show_help" },
      { text: "üñ•Ô∏è VPS Setup", callback_data: "vps_setup" }
    ]
  ]);
  
  await sendMessage(chatId, message, { replyMarkup: keyboard });
}

async function handlePredictCommand(chatId: number, command: string, userId?: number): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";

  try {
    const userPrefs = userId ? await getUserPreferences(userId) : null;
    const strategy = userPrefs?.tradingMode;
    
    const strategyText = strategy ? ` using your preferred ${strategy} mode` : "";
    
    await sendMessage(chatId, `üß† **Advanced ML Analysis for ${symbol}**${strategyText}\n\nüîç Analyzing market structure, smart money flow, and determining optimal strategy...\n\n‚è≥ This may take 10-15 seconds for comprehensive analysis.`);
    
    const prediction = await predict({ 
      symbol, 
      strategy,
      userPreferences: userPrefs || undefined
    });
    
    await sendTradingSignal(chatId, prediction, userPrefs);
  } catch (error) {
    console.error("Prediction error:", error);
    await sendMessage(chatId, "‚ùå Error generating prediction. Please try again or check if the symbol is valid.");
  }
}

async function handleStrategyCommand(chatId: number, command: string, strategy: "SCALPING" | "INTRADAY" | "SWING", userId?: number): Promise<void> {
  const parts = command.split(" ");
  const symbol = parts[1]?.toUpperCase() || "BTCUSD";

  try {
    const userPrefs = userId ? await getUserPreferences(userId) : null;
    
    const strategyEmojis = {
      "SCALPING": "‚ö°",
      "INTRADAY": "üìà", 
      "SWING": "üéØ"
    };

    await sendMessage(chatId, `${strategyEmojis[strategy]} **${strategy} Analysis for ${symbol}**\n\nüîç Analyzing market for ${strategy.toLowerCase()} opportunities...\n\n‚è≥ Optimizing entry, stop loss, and take profit levels...`);
    
    const prediction = await predict({ 
      symbol, 
      strategy,
      userPreferences: userPrefs || undefined
    });
    
    await sendTradingSignal(chatId, prediction, userPrefs);
  } catch (error) {
    console.error("Strategy prediction error:", error);
    await sendMessage(chatId, `‚ùå Error generating ${strategy.toLowerCase()} analysis. Please try again.`);
  }
}

async function sendTradingSignal(chatId: number, prediction: any, userPrefs?: UserPreferences | null): Promise<void> {
  const strategyEmojis = {
    "SCALPING": "‚ö°",
    "INTRADAY": "üìà",
    "SWING": "üéØ"
  };

  const confidenceEmoji = prediction.confidence >= 85 ? "üî•" : prediction.confidence >= 75 ? "‚ö°" : "‚ö†Ô∏è";
  const strategyEmoji = strategyEmojis[prediction.strategy] || "üìä";
  
  // Calculate position size based on user preferences
  let positionSizeInfo = "";
  if (userPrefs && userPrefs.accountBalance && userPrefs.riskPercentage) {
    const riskAmount = userPrefs.accountBalance * (userPrefs.riskPercentage / 100);
    const stopLossDistance = Math.abs(prediction.entryPrice - prediction.stopLoss);
    const suggestedLotSize = Math.min(riskAmount / stopLossDistance, 2.0); // Max 2 lots
    
    positionSizeInfo = `

üéØ **Your Position Sizing:**
‚Ä¢ Account Balance: $${userPrefs.accountBalance.toLocaleString()}
‚Ä¢ Risk Amount: $${riskAmount.toFixed(2)} (${userPrefs.riskPercentage}%)
‚Ä¢ Suggested Lot Size: ${Math.round(suggestedLotSize * 100) / 100} lots`;
  }
  
  const message = `
${strategyEmoji} **${prediction.strategy} Signal - ${prediction.symbol}**

üÜî **Trade ID:** \`${prediction.tradeId}\`
üìà **Direction:** **${prediction.direction}**
üí∞ **Entry Price:** ${prediction.entryPrice}
üéØ **Take Profit:** ${prediction.takeProfit}
üõ°Ô∏è **Stop Loss:** ${prediction.stopLoss}
${confidenceEmoji} **Confidence:** **${prediction.confidence}%**
üìä **Risk/Reward:** 1:${prediction.riskRewardRatio}
üíé **Recommended Size:** ${prediction.recommendedLotSize} lots
‚è±Ô∏è **Max Hold Time:** ${prediction.maxHoldingTime}h${positionSizeInfo}

üìä **Strategy Analysis:**
${prediction.strategyRecommendation}

üß† **AI Technical Analysis:**
‚Ä¢ **Trend:** ${prediction.analysis.priceAction.trend}
‚Ä¢ **Support:** ${prediction.analysis.support}
‚Ä¢ **Resistance:** ${prediction.analysis.resistance}
‚Ä¢ **Smart Money:** ${prediction.analysis.smartMoney.institutionalFlow}

üèõÔ∏è **Institutional Insights:**
${prediction.analysis.smartMoney.liquidityZones.slice(0, 3).map(zone => `‚Ä¢ ${zone.toFixed(2)} (${zone > prediction.entryPrice ? "Resistance" : "Support"})`).join('\n')}

üí° **Risk Management:**
Always use stop loss and never risk more than 2% of your account per trade.
  `;

  // Create inline keyboard for quick actions
  const suggestedSize = userPrefs && userPrefs.accountBalance ? 
    Math.min(userPrefs.accountBalance * (userPrefs.riskPercentage || 2) / 100 / Math.abs(prediction.entryPrice - prediction.stopLoss), 2.0) :
    prediction.recommendedLotSize;
  
  const keyboard = createInlineKeyboard([
    [
      { text: `${strategyEmoji} Execute ${Math.round(suggestedSize * 100) / 100}`, callback_data: `execute_${prediction.tradeId}_${Math.round(suggestedSize * 100) / 100}_${prediction.strategy}` },
      { text: `${strategyEmoji} Execute 0.01`, callback_data: `execute_${prediction.tradeId}_0.01_${prediction.strategy}` }
    ],
    [
      { text: "üìä New Analysis", callback_data: "new_analysis" },
      { text: "üìà Performance", callback_data: "show_performance" }
    ]
  ]);

  await sendMessage(chatId, message, { replyMarkup: keyboard });
}
